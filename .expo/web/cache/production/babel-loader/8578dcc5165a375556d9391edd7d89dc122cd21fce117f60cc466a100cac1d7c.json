{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import escape from'escape-string-regexp';import queryString from'query-string';import checkLegacyPathConfig from\"./checkLegacyPathConfig\";export default function getStateFromPath(path,options){var _ref;var _checkLegacyPathConfi=checkLegacyPathConfig(options),_checkLegacyPathConfi2=_slicedToArray(_checkLegacyPathConfi,2),legacy=_checkLegacyPathConfi2[0],compatOptions=_checkLegacyPathConfi2[1];var initialRoutes=[];if(compatOptions===null||compatOptions===void 0?void 0:compatOptions.initialRouteName){initialRoutes.push({initialRouteName:compatOptions.initialRouteName,connectedRoutes:Object.keys(compatOptions.screens)});}var screens=compatOptions===null||compatOptions===void 0?void 0:compatOptions.screens;var remaining=path.replace(/\\/+/g,'/').replace(/^\\//,'').replace(/\\?.*$/,'');remaining=remaining.endsWith('/')?remaining:\"\".concat(remaining,\"/\");if(screens===undefined){var routes=remaining.split('/').filter(Boolean).map(function(segment,i,self){var name=decodeURIComponent(segment);if(i===self.length-1){return{name:name,params:parseQueryParams(path)};}return{name:name};});if(routes.length){return createNestedStateObject(routes,initialRoutes);}return undefined;}var configs=(_ref=[]).concat.apply(_ref,_toConsumableArray(Object.keys(screens).map(function(key){return createNormalizedConfigs(legacy,key,screens,[],initialRoutes);}))).sort(function(a,b){if(a.pattern.startsWith(b.pattern)){return-1;}if(b.pattern.startsWith(a.pattern)){return 1;}var aParts=a.pattern.split('/');var bParts=b.pattern.split('/');var aWildcardIndex=aParts.indexOf('*');var bWildcardIndex=bParts.indexOf('*');if(aWildcardIndex===-1&&bWildcardIndex!==-1){return-1;}if(aWildcardIndex!==-1&&bWildcardIndex===-1){return 1;}if(aWildcardIndex===bWildcardIndex){return bParts.length-aParts.length;}return bWildcardIndex-aWildcardIndex;});if(remaining==='/'){var match=configs.find(function(config){return config.path===''&&config.routeNames.every(function(name){var _configs$find;return!((_configs$find=configs.find(function(c){return c.screen===name;}))===null||_configs$find===void 0?void 0:_configs$find.path);});});if(match){return createNestedStateObject(match.routeNames.map(function(name,i,self){if(i===self.length-1){return{name:name,params:parseQueryParams(path,match.parse)};}return{name:name};}),initialRoutes);}return undefined;}var result;var current;if(legacy===false){var _matchAgainstConfigs=matchAgainstConfigs(remaining,configs.map(function(c){return _objectSpread(_objectSpread({},c),{},{regex:c.regex?new RegExp(c.regex.source+'$'):undefined});})),routeNames=_matchAgainstConfigs.routeNames,allParams=_matchAgainstConfigs.allParams,remainingPath=_matchAgainstConfigs.remainingPath;if(routeNames!==undefined){remaining=remainingPath;current=createNestedStateObject(createRouteObjects(configs,routeNames,allParams),initialRoutes);result=current;}}else{while(remaining){var _matchAgainstConfigs2=matchAgainstConfigs(remaining,configs),_routeNames=_matchAgainstConfigs2.routeNames,_allParams=_matchAgainstConfigs2.allParams,_remainingPath=_matchAgainstConfigs2.remainingPath;remaining=_remainingPath;if(_routeNames===undefined){var segments=remaining.split('/');_routeNames=[decodeURIComponent(segments[0])];segments.shift();remaining=segments.join('/');}var state=createNestedStateObject(createRouteObjects(configs,_routeNames,_allParams),initialRoutes);if(current){var _current2;while((_current=current)===null||_current===void 0?void 0:_current.routes[current.index||0].state){var _current;current=current.routes[current.index||0].state;}current.routes[((_current2=current)===null||_current2===void 0?void 0:_current2.index)||0].state=state;}else{result=state;}current=state;}}if(current==null||result==null){return undefined;}var route=findFocusedRoute(current);var params=parseQueryParams(path,findParseConfigForRoute(route.name,configs));if(params){route.params=_objectSpread(_objectSpread({},route.params),params);}return result;}var joinPaths=function joinPaths(){var _ref2;for(var _len=arguments.length,paths=new Array(_len),_key=0;_key<_len;_key++){paths[_key]=arguments[_key];}return(_ref2=[]).concat.apply(_ref2,_toConsumableArray(paths.map(function(p){return p.split('/');}))).filter(Boolean).join('/');};var matchAgainstConfigs=function matchAgainstConfigs(remaining,configs){var routeNames;var allParams;var remainingPath=remaining;var _loop=function _loop(config){if(!config.regex){return\"continue\";}var match=remainingPath.match(config.regex);if(match){routeNames=_toConsumableArray(config.routeNames);var paramPatterns=config.pattern.split('/').filter(function(p){return p.startsWith(':');});if(paramPatterns.length){allParams=paramPatterns.reduce(function(acc,p,i){var value=match[(i+1)*2].replace(/\\//,'');acc[p]=value;return acc;},{});}remainingPath=remainingPath.replace(match[1],'');return\"break\";}};for(var _iterator=_createForOfIteratorHelperLoose(configs),_step;!(_step=_iterator()).done;){var config=_step.value;var _ret=_loop(config);if(_ret===\"continue\")continue;if(_ret===\"break\")break;}return{routeNames:routeNames,allParams:allParams,remainingPath:remainingPath};};var createNormalizedConfigs=function createNormalizedConfigs(legacy,screen,routeConfig){var routeNames=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];var initials=arguments.length>4?arguments[4]:undefined;var parentPattern=arguments.length>5?arguments[5]:undefined;var configs=[];routeNames.push(screen);var config=routeConfig[screen];if(typeof config==='string'){var pattern=parentPattern?joinPaths(parentPattern,config):config;configs.push(createConfigItem(legacy,screen,routeNames,pattern,config));}else if(typeof config==='object'){var _pattern2;if(typeof config.path==='string'){if(legacy){_pattern2=config.exact!==true&&parentPattern?joinPaths(parentPattern,config.path):config.path;}else{if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}_pattern2=config.exact!==true?joinPaths(parentPattern||'',config.path||''):config.path||'';}configs.push(createConfigItem(legacy,screen,routeNames,_pattern2,config.path,config.parse));}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,connectedRoutes:Object.keys(config.screens)});}Object.keys(config.screens).forEach(function(nestedConfig){var _pattern;var result=createNormalizedConfigs(legacy,nestedConfig,config.screens,routeNames,initials,(_pattern=_pattern2)!==null&&_pattern!==void 0?_pattern:parentPattern);configs.push.apply(configs,_toConsumableArray(result));});}}routeNames.pop();return configs;};var createConfigItem=function createConfigItem(legacy,screen,routeNames,pattern,path,parse){pattern=pattern.split('/').filter(Boolean).join('/');var regex=pattern?new RegExp(\"^(\".concat(pattern.split('/').map(function(it){if(legacy&&it==='*'){throw new Error(\"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/configuring-links/#updating-config\");}if(it.startsWith(':')){return\"(([^/]+\\\\/)\".concat(it.endsWith('?')?'?':'',\")\");}return\"\".concat(it==='*'?'.*':escape(it),\"\\\\/\");}).join(''),\")\")):undefined;return{screen:screen,regex:regex,pattern:pattern,path:path,routeNames:_toConsumableArray(routeNames),parse:parse};};var findParseConfigForRoute=function findParseConfigForRoute(routeName,flatConfig){for(var _iterator2=_createForOfIteratorHelperLoose(flatConfig),_step2;!(_step2=_iterator2()).done;){var config=_step2.value;if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};var findInitialRoute=function findInitialRoute(routeName,initialRoutes){for(var _iterator3=_createForOfIteratorHelperLoose(initialRoutes),_step3;!(_step3=_iterator3()).done;){var config=_step3.value;if(config.connectedRoutes.includes(routeName)){return config.initialRouteName===routeName?undefined:config.initialRouteName;}}return undefined;};var createStateObject=function createStateObject(initialRoute,routeName,params,isEmpty){if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},{name:routeName,params:params}]};}else{return{routes:[{name:routeName,params:params}]};}}else{if(initialRoute){return{index:1,routes:[{name:initialRoute},{name:routeName,params:params,state:{routes:[]}}]};}else{return{routes:[{name:routeName,params:params,state:{routes:[]}}]};}}};var createNestedStateObject=function createNestedStateObject(routes,initialRoutes){var state;var route=routes.shift();var initialRoute=findInitialRoute(route.name,initialRoutes);state=createStateObject(initialRoute,route.name,route.params,routes.length===0);if(routes.length>0){var nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,initialRoutes);var nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(initialRoute,route.name,route.params,routes.length===0);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}}}return state;};var createRouteObjects=function createRouteObjects(configs,routeNames,allParams){return routeNames.map(function(name){var config=configs.find(function(c){return c.screen===name;});var params;if(allParams&&(config===null||config===void 0?void 0:config.path)){var pattern=config.path;if(pattern){var paramPatterns=pattern.split('/').filter(function(p){return p.startsWith(':');});if(paramPatterns.length){params=paramPatterns.reduce(function(acc,p){var key=p.replace(/^:/,'').replace(/\\?$/,'');var value=allParams[p];if(value){var _config$parse;acc[key]=((_config$parse=config.parse)===null||_config$parse===void 0?void 0:_config$parse[key])?config.parse[key](value):value;}return acc;},{});}}}if(params&&Object.keys(params).length){return{name:name,params:params};}return{name:name};});};var findFocusedRoute=function findFocusedRoute(state){var _current4;var current=state;while((_current3=current)===null||_current3===void 0?void 0:_current3.routes[current.index||0].state){var _current3;current=current.routes[current.index||0].state;}var route=current.routes[((_current4=current)===null||_current4===void 0?void 0:_current4.index)||0];return route;};var parseQueryParams=function parseQueryParams(path,parseConfig){var query=path.split('?')[1];var params=queryString.parse(query);if(parseConfig){Object.keys(params).forEach(function(name){if(parseConfig[name]&&typeof params[name]==='string'){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;};","map":{"version":3,"mappings":"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","names":["escape","queryString","checkLegacyPathConfig","getStateFromPath","path","options","legacy","compatOptions","initialRoutes","initialRouteName","push","connectedRoutes","Object","keys","screens","remaining","replace","endsWith","undefined","routes","split","filter","Boolean","map","segment","i","self","name","decodeURIComponent","length","params","parseQueryParams","createNestedStateObject","configs","concat","key","createNormalizedConfigs","sort","a","b","pattern","startsWith","aParts","bParts","aWildcardIndex","indexOf","bWildcardIndex","match","find","config","routeNames","every","c","screen","_configs$find","parse","result","current","matchAgainstConfigs","regex","RegExp","source","allParams","remainingPath","createRouteObjects","segments","shift","join","state","_current","index","route","findFocusedRoute","findParseConfigForRoute","joinPaths","paths","p","paramPatterns","reduce","acc","value","routeConfig","initials","parentPattern","createConfigItem","exact","Error","forEach","nestedConfig","pop","it","routeName","flatConfig","findInitialRoute","includes","createStateObject","initialRoute","isEmpty","nestedState","nestedStateIndex","_current3","parseConfig","query"],"sources":["/Users/michaeladmin/Documents/GitHub/vidnation/node_modules/@react-navigation/core/lib/module/getStateFromPath.tsx"],"sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport type {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\nimport checkLegacyPathConfig from './checkLegacyPathConfig';\nimport type { PathConfigMap } from './types';\n\ntype Options = {\n  initialRouteName?: string;\n  screens: PathConfigMap;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options?: Options\n): ResultState | undefined {\n  const [legacy, compatOptions] = checkLegacyPathConfig(options);\n\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  if (compatOptions?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: compatOptions.initialRouteName,\n      connectedRoutes: Object.keys(compatOptions.screens),\n    });\n  }\n\n  const screens = compatOptions?.screens;\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment, i, self) => {\n        const name = decodeURIComponent(segment);\n\n        if (i === self.length - 1) {\n          return { name, params: parseQueryParams(path) };\n        }\n\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(routes, initialRoutes);\n    }\n\n    return undefined;\n  }\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(\n          legacy,\n          key,\n          screens as PathConfigMap,\n          [],\n          initialRoutes\n        )\n      )\n    )\n    .sort((a, b) => {\n      // Sort config so that:\n      // - the most exhaustive ones are always at the beginning\n      // - patterns with wildcard are always at the end\n\n      // If one of the patterns starts with the other, it's more exhaustive\n      // So move it up\n      if (a.pattern.startsWith(b.pattern)) {\n        return -1;\n      }\n\n      if (b.pattern.startsWith(a.pattern)) {\n        return 1;\n      }\n\n      const aParts = a.pattern.split('/');\n      const bParts = b.pattern.split('/');\n\n      const aWildcardIndex = aParts.indexOf('*');\n      const bWildcardIndex = bParts.indexOf('*');\n\n      // If only one of the patterns has a wildcard, move it down in the list\n      if (aWildcardIndex === -1 && bWildcardIndex !== -1) {\n        return -1;\n      }\n\n      if (aWildcardIndex !== -1 && bWildcardIndex === -1) {\n        return 1;\n      }\n\n      if (aWildcardIndex === bWildcardIndex) {\n        // If `b` has more `/`, it's more exhaustive\n        // So we move it up in the list\n        return bParts.length - aParts.length;\n      }\n\n      // If the wildcard appears later in the pattern (has higher index), it's more specific\n      // So we move it up in the list\n      return bWildcardIndex - aWildcardIndex;\n    });\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.path === '' &&\n        config.routeNames.every(\n          // Make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.path\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames.map((name, i, self) => {\n          if (i === self.length - 1) {\n            return { name, params: parseQueryParams(path, match.parse) };\n          }\n\n          return { name };\n        }),\n        initialRoutes\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  if (legacy === false) {\n    // If we're not in legacy mode,, we match the whole path against the regex instead of segments\n    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n    const { routeNames, allParams, remainingPath } = matchAgainstConfigs(\n      remaining,\n      configs.map((c) => ({\n        ...c,\n        // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n        regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n      }))\n    );\n\n    if (routeNames !== undefined) {\n      // This will always be empty if full path matched\n      remaining = remainingPath;\n      current = createNestedStateObject(\n        createRouteObjects(configs, routeNames, allParams),\n        initialRoutes\n      );\n      result = current;\n    }\n  } else {\n    // In legacy mode, we divide the path into segments and match piece by piece\n    // This preserves the legacy behaviour, but we should remove it in next major\n    while (remaining) {\n      let { routeNames, allParams, remainingPath } = matchAgainstConfigs(\n        remaining,\n        configs\n      );\n\n      remaining = remainingPath;\n\n      // If we hadn't matched any segments earlier, use the path as route name\n      if (routeNames === undefined) {\n        const segments = remaining.split('/');\n\n        routeNames = [decodeURIComponent(segments[0])];\n        segments.shift();\n        remaining = segments.join('/');\n      }\n\n      const state = createNestedStateObject(\n        createRouteObjects(configs, routeNames, allParams),\n        initialRoutes\n      );\n\n      if (current) {\n        // The state should be nested inside the deepest route we parsed before\n        while (current?.routes[current.index || 0].state) {\n          current = current.routes[current.index || 0].state;\n        }\n\n        (current as PartialState<NavigationState>).routes[\n          current?.index || 0\n        ].state = state;\n      } else {\n        result = state;\n      }\n\n      current = state;\n    }\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    // @ts-expect-error: params should be treated as read-only, but we're creating the state here so it doesn't matter\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routeNames: string[] | undefined;\n  let allParams: Record<string, any> | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      routeNames = [...config.routeNames];\n\n      const paramPatterns = config.pattern\n        .split('/')\n        .filter((p) => p.startsWith(':'));\n\n      if (paramPatterns.length) {\n        allParams = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n          const value = match![(i + 1) * 2].replace(/\\//, ''); // The param segments appear every second item starting from 2 in the regex match result\n\n          acc[p] = value;\n\n          return acc;\n        }, {});\n      }\n\n      remainingPath = remainingPath.replace(match[1], '');\n\n      break;\n    }\n  }\n\n  return { routeNames, allParams, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  legacy: boolean,\n  screen: string,\n  routeConfig: PathConfigMap,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(legacy, screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (legacy) {\n        pattern =\n          config.exact !== true && parentPattern\n            ? joinPaths(parentPattern, config.path)\n            : config.path;\n      } else {\n        if (config.exact && config.path === undefined) {\n          throw new Error(\n            \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n          );\n        }\n\n        pattern =\n          config.exact !== true\n            ? joinPaths(parentPattern || '', config.path || '')\n            : config.path || '';\n      }\n\n      configs.push(\n        createConfigItem(\n          legacy,\n          screen,\n          routeNames,\n          pattern,\n          config.path,\n          config.parse\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          connectedRoutes: Object.keys(config.screens),\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          legacy,\n          nestedConfig,\n          config.screens as PathConfigMap,\n          routeNames,\n          initials,\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  legacy: boolean,\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  parse?: ParseConfig\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (legacy && it === '*') {\n              throw new Error(\n                \"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/configuring-links/#updating-config\"\n              );\n            }\n\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${it === '*' ? '.*' : escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  routeName: string,\n  params: Record<string, any> | undefined,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { name: routeName as string, params }],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, params, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  routes: { name: string; params?: object }[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let state: InitialState;\n  let route = routes.shift() as { name: string; params?: object };\n  let initialRoute = findInitialRoute(route.name, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    route.name,\n    route.params,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as { name: string; params?: object })) {\n      initialRoute = findInitialRoute(route.name, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route.name,\n        route.params,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n};\n\nconst createRouteObjects = (\n  configs: RouteConfig[],\n  routeNames: string[],\n  allParams?: Record<string, any>\n) =>\n  routeNames.map((name) => {\n    const config = configs.find((c) => c.screen === name);\n\n    let params: object | undefined;\n\n    if (allParams && config?.path) {\n      const pattern = config.path;\n\n      if (pattern) {\n        const paramPatterns = pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p) => {\n            const key = p.replace(/^:/, '').replace(/\\?$/, '');\n            const value = allParams![p];\n\n            if (value) {\n              acc[key] = config.parse?.[key] ? config.parse[key](value) : value;\n            }\n\n            return acc;\n          }, {});\n        }\n      }\n    }\n\n    if (params && Object.keys(params).length) {\n      return { name, params };\n    }\n\n    return { name };\n  });\n\nconst findFocusedRoute = (state: InitialState) => {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) => {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}