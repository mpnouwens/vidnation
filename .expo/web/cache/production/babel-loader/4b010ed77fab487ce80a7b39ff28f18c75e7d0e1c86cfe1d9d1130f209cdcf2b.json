{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import{Platform}from'@unimodules/core';import path from'path-browserify';import PixelRatio from\"react-native-web/dist/exports/PixelRatio\";import URL from'url-parse';import AssetSourceResolver from\"./AssetSourceResolver\";import{manifestBaseUrl,getManifest}from\"./PlatformUtils\";var assetMapOverride=getManifest().assetMapOverride;export function selectAssetSource(meta){if(assetMapOverride&&assetMapOverride.hasOwnProperty(meta.hash)){meta=_objectSpread(_objectSpread({},meta),assetMapOverride[meta.hash]);}var scale=AssetSourceResolver.pickScale(meta.scales,PixelRatio.get());var index=meta.scales.findIndex(function(s){return s===scale;});var hash=meta.fileHashes?meta.fileHashes[index]||meta.fileHashes[0]:meta.hash;var uri=meta.fileUris?meta.fileUris[index]||meta.fileUris[0]:meta.uri;if(uri){return{uri:resolveUri(uri),hash:hash};}var assetUrlOverride=getManifest().assetUrlOverride;if(assetUrlOverride){var _uri=path.join(assetUrlOverride,hash);return{uri:resolveUri(_uri),hash:hash};}var fileScale=scale===1?'':\"@\"+scale+\"x\";var fileExtension=meta.type?\".\"+encodeURIComponent(meta.type):'';var suffix=\"/\"+encodeURIComponent(meta.name)+fileScale+fileExtension+\"?platform=\"+encodeURIComponent(Platform.OS)+\"&hash=\"+encodeURIComponent(meta.hash);if(/^https?:\\/\\//.test(meta.httpServerLocation)){var _uri2=meta.httpServerLocation+suffix;return{uri:_uri2,hash:hash};}if(getManifest().developer){var baseUrl=new URL(getManifest().bundleUrl);baseUrl.set('pathname',meta.httpServerLocation+suffix);return{uri:baseUrl.href,hash:hash};}return{uri:\"https://d1wp6m56sqw74a.cloudfront.net/~assets/\"+encodeURIComponent(hash),hash:hash};}export function resolveUri(uri){if(!manifestBaseUrl){return uri;}var _URL=new URL(uri),protocol=_URL.protocol;if(protocol!==''){return uri;}var baseUrl=new URL(manifestBaseUrl);var resolvedPath=uri.startsWith('/')?uri:path.join(baseUrl.pathname,uri);baseUrl.set('pathname',resolvedPath);return baseUrl.href;}","map":{"version":3,"mappings":"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","names":["Platform","path","URL","AssetSourceResolver","manifestBaseUrl","getManifest","assetMapOverride","selectAssetSource","meta","hasOwnProperty","hash","scale","pickScale","scales","PixelRatio","get","index","findIndex","s","fileHashes","uri","fileUris","resolveUri","assetUrlOverride","join","fileScale","fileExtension","type","encodeURIComponent","suffix","name","OS","test","httpServerLocation","developer","baseUrl","bundleUrl","set","href","protocol","resolvedPath","startsWith","pathname"],"sources":["/Users/michaeladmin/Documents/GitHub/vidnation/node_modules/expo-asset/src/AssetSources.ts"],"sourcesContent":["import { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\n\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { manifestBaseUrl, getManifest } from './PlatformUtils';\n\nexport type AssetMetadata = {\n  hash: string;\n  name: string;\n  type: string;\n  width?: number;\n  height?: number;\n  scales: number[];\n  httpServerLocation: string;\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta, ...assetMapOverride[meta.hash] };\n  }\n\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(\n    meta.name\n  )}${fileScale}${fileExtension}?platform=${encodeURIComponent(\n    Platform.OS\n  )}&hash=${encodeURIComponent(meta.hash)}`;\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return { uri, hash };\n  }\n\n  // For assets during development, we use the development server's URL origin\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return { uri: baseUrl.href, hash };\n  }\n\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n    hash,\n  };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const { protocol } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}