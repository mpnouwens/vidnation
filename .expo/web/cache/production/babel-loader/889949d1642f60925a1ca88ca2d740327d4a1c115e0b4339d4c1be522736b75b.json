{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _assertThisInitialized from\"@babel/runtime/helpers/assertThisInitialized\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import*as React from'react';import TextInput from\"react-native-web/dist/exports/TextInput\";import Platform from\"react-native-web/dist/exports/Platform\";import Keyboard from\"react-native-web/dist/exports/Keyboard\";var KeyboardManager=function(_React$Component){_inherits(KeyboardManager,_React$Component);var _super=_createSuper(KeyboardManager);function KeyboardManager(){var _this;_classCallCheck(this,KeyboardManager);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_defineProperty(_assertThisInitialized(_this),\"previouslyFocusedTextInput\",null);_defineProperty(_assertThisInitialized(_this),\"startTimestamp\",0);_defineProperty(_assertThisInitialized(_this),\"keyboardTimeout\",void 0);_defineProperty(_assertThisInitialized(_this),\"clearKeyboardTimeout\",function(){if(_this.keyboardTimeout!==undefined){clearTimeout(_this.keyboardTimeout);_this.keyboardTimeout=undefined;}});_defineProperty(_assertThisInitialized(_this),\"handlePageChangeStart\",function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();var input=TextInput.State.currentlyFocusedInput?TextInput.State.currentlyFocusedInput():TextInput.State.currentlyFocusedField();TextInput.State.blurTextInput(input);_this.previouslyFocusedTextInput=input;_this.startTimestamp=Date.now();});_defineProperty(_assertThisInitialized(_this),\"handlePageChangeConfirm\",function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();var input=_this.previouslyFocusedTextInput;if(Platform.OS==='android'){Keyboard.dismiss();}else if(input){TextInput.State.blurTextInput(input);}_this.previouslyFocusedTextInput=null;});_defineProperty(_assertThisInitialized(_this),\"handlePageChangeCancel\",function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();var input=_this.previouslyFocusedTextInput;if(input){if(Date.now()-_this.startTimestamp<100){_this.keyboardTimeout=setTimeout(function(){TextInput.State.focusTextInput(input);_this.previouslyFocusedTextInput=null;},100);}else{TextInput.State.focusTextInput(input);_this.previouslyFocusedTextInput=null;}}});return _this;}_createClass(KeyboardManager,[{key:\"componentWillUnmount\",value:function componentWillUnmount(){this.clearKeyboardTimeout();}},{key:\"render\",value:function render(){return this.props.children({onPageChangeStart:this.handlePageChangeStart,onPageChangeConfirm:this.handlePageChangeConfirm,onPageChangeCancel:this.handlePageChangeCancel});}}]);return KeyboardManager;}(React.Component);export{KeyboardManager as default};","map":{"version":3,"mappings":"4wCAAA,MAAO,GAAKA,MAAZ,KAAuB,OAAvB,6LAYqBC,gBAAN,iHAAqD,kTAOjB,IAPiB,iEAQjC,CARiC,+IAWnC,UAAM,CACnC,GAAI,MAAKC,eAAL,GAAyBC,SAA7B,CAAwC,CACtCC,YAAY,CAAC,MAAKF,eAAN,CAAZ,CACA,MAAKA,eAAL,CAAuBC,SAAvB,CACD,CACF,CAhBiE,wEAkBlC,UAAM,CACpC,GAAI,CAAC,MAAKE,KAAL,CAAWC,OAAhB,CAAyB,CACvB,OACD,CAED,MAAKC,oBAAL,GAEA,GAAMC,MAAU,CAAGC,SAAS,CAACC,KAAV,CAAgBC,qBAAhB,CACfF,SAAS,CAACC,KAAV,CAAgBC,qBAAhB,EADe,CAEfF,SAAS,CAACC,KAAV,CAAgBE,qBAAhB,EAFJ,CAKAH,SAAS,CAACC,KAAV,CAAgBG,aAAhB,CAA8BL,KAA9B,EAGA,MAAKM,0BAAL,CAAkCN,KAAlC,CAGA,MAAKO,cAAL,CAAsBC,IAAI,CAACC,GAAL,EAAtB,CACD,CArCiE,0EAuChC,UAAM,CACtC,GAAI,CAAC,MAAKZ,KAAL,CAAWC,OAAhB,CAAyB,CACvB,OACD,CAED,MAAKC,oBAAL,GAEA,GAAMC,MAAK,CAAG,MAAKM,0BAAnB,CAEA,GAAII,QAAQ,CAACC,EAAT,GAAgB,SAApB,CAA+B,CAC7BC,QAAQ,CAACC,OAAT,GACD,CAFD,IAEO,IAAIb,KAAJ,CAAW,CAChBC,SAAS,CAACC,KAAV,CAAgBG,aAAhB,CAA8BL,KAA9B,EACD,CAGD,MAAKM,0BAAL,CAAkC,IAAlC,CACD,CAxDiE,yEA0DjC,UAAM,CACrC,GAAI,CAAC,MAAKT,KAAL,CAAWC,OAAhB,CAAyB,CACvB,OACD,CAED,MAAKC,oBAAL,GAGA,GAAMC,MAAK,CAAG,MAAKM,0BAAnB,CAEA,GAAIN,KAAJ,CAAW,CAQT,GAAIQ,IAAI,CAACC,GAAL,GAAa,MAAKF,cAAlB,CAAmC,GAAvC,CAA4C,CAC1C,MAAKb,eAAL,CAAuBoB,UAAU,CAAC,UAAM,CACtCb,SAAS,CAACC,KAAV,CAAgBa,cAAhB,CAA+Bf,KAA/B,EACA,MAAKM,0BAAL,CAAkC,IAAlC,CACD,CAHgC,CAG9B,GAH8B,CAAjC,CAID,CALD,IAKO,CACLL,SAAS,CAACC,KAAV,CAAgBa,cAAhB,CAA+Bf,KAA/B,EACA,MAAKM,0BAAL,CAAkC,IAAlC,CACD,CACF,CACF,CAtFiE,+GAC3C,CACrB,KAAKP,oBAAL,GACD,CAHiE,uCAwFzD,CACP,MAAO,MAAKF,KAAL,CAAWmB,QAAX,CAAoB,CACzBC,iBAAiB,CAAE,KAAKC,qBADC,CAEzBC,mBAAmB,CAAE,KAAKC,uBAFD,CAGzBC,kBAAkB,CAAE,KAAKC,sBAHA,CAApB,CAAP,CAKD,8BA9F0C9B,KAAK,CAAC+B,SAApC,SAAM9B,eAAN","names":["React","KeyboardManager","keyboardTimeout","undefined","clearTimeout","props","enabled","clearKeyboardTimeout","input","TextInput","State","currentlyFocusedInput","currentlyFocusedField","blurTextInput","previouslyFocusedTextInput","startTimestamp","Date","now","Platform","OS","Keyboard","dismiss","setTimeout","focusTextInput","children","onPageChangeStart","handlePageChangeStart","onPageChangeConfirm","handlePageChangeConfirm","onPageChangeCancel","handlePageChangeCancel","Component"],"sources":["/Users/michaeladmin/Documents/GitHub/vidnation/node_modules/@react-navigation/stack/lib/module/views/KeyboardManager.tsx"],"sourcesContent":["import * as React from 'react';\nimport { TextInput, Platform, Keyboard } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: () => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: any | null = null;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    const input: any = TextInput.State.currentlyFocusedInput\n      ? TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    const input = this.previouslyFocusedTextInput;\n\n    if (Platform.OS === 'android') {\n      Keyboard.dismiss();\n    } else if (input) {\n      TextInput.State.blurTextInput(input);\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = null;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = null;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = null;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}