{"ast":null,"code":"import _extends from\"@babel/runtime/helpers/extends\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{EventEmitter}from'fbemitter';import React from'react';import NativeAppLoading from\"./AppLoadingNativeWrapper\";var AppLoading=function(_React$Component){_inherits(AppLoading,_React$Component);var _super=_createSuper(AppLoading);function AppLoading(){var _this;_classCallCheck(this,AppLoading);_this=_super.apply(this,arguments);_this._isMounted=false;_this._startLoadingAppResourcesAsync=function _callee(){return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(_this.props.onFinish){_context.next=2;break;}throw new Error('AppLoading onFinish prop is required if startAsync is provided');case 2:_context.prev=2;_context.next=5;return _regeneratorRuntime.awrap(_this.props.startAsync());case 5:_context.next=16;break;case 7:_context.prev=7;_context.t0=_context[\"catch\"](2);if(_this._isMounted){_context.next=11;break;}return _context.abrupt(\"return\");case 11:if(!_this.props.onError){_context.next=15;break;}_this.props.onError(_context.t0);_context.next=16;break;case 15:throw _context.t0;case 16:_context.prev=16;if(_this._isMounted){_context.next=19;break;}return _context.abrupt(\"return\");case 19:if(_this.props.onFinish){_this.props.onFinish();}return _context.finish(16);case 21:case\"end\":return _context.stop();}}},null,null,[[2,7,16,21]],Promise);};return _this;}_createClass(AppLoading,[{key:\"componentDidMount\",value:function componentDidMount(){this._isMounted=true;_emitEvent('componentDidMount');if(this.props.startAsync){this._startLoadingAppResourcesAsync().catch(function(error){console.error(\"AppLoading threw an unexpected error when loading:\\n\"+error.stack);});}}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){this._isMounted=false;_emitEvent('componentWillUnmount');}},{key:\"render\",value:function render(){return React.createElement(NativeAppLoading,_extends({},this.props));}}]);return AppLoading;}(React.Component);export{AppLoading as default};var _lifecycleEmitter=null;function _emitEvent(event){if(_lifecycleEmitter){_lifecycleEmitter.emit(event);}}export function getAppLoadingLifecycleEmitter(){if(!_lifecycleEmitter){_lifecycleEmitter=new EventEmitter();}return _lifecycleEmitter;}","map":{"version":3,"mappings":"snCAAA,OAASA,YAAY,KAAQ,WAAW,CACxC,MAAOC,MAAK,KAAM,OAAO,CAEzB,MAAOC,iBAAgB,iCAAkC,GAepCC,WAAW,uGAAhC,oGACE,gBAAU,CAAY,KAAK,CAoB3B,oCAA8B,CAAG,uIAC1B,MAAKC,KAAK,CAACC,QAAQ,8BAChB,IAAIC,MAAK,CAAC,gEAAgE,CAAC,yEAI3E,MAAKF,KAAK,CAACG,UAAW,EAAE,2FAEzB,MAAKC,UAAU,uEAEhB,MAAKJ,KAAK,CAACK,OAAO,0BACpB,MAAKL,KAAK,CAACK,OAAO,aAAG,CAAC,6EAKnB,MAAKD,UAAU,mEAIpB,GAAI,MAAKJ,KAAK,CAACC,QAAQ,CAAE,CACvB,MAAKD,KAAK,CAACC,QAAQ,EAAE,EACtB,0GAEJ,CAAC,aAKJ,CAAC,oFA/CkB,CACf,IAAI,CAACG,UAAU,CAAG,IAAI,CACtBE,UAAU,CAAC,mBAAmB,CAAC,CAI/B,GAAI,IAAI,CAACN,KAAK,CAACG,UAAU,CAAE,CACzB,IAAI,CAACI,8BAA8B,EAAE,CAACC,KAAK,CAAC,cAAK,CAAG,CAClDC,OAAO,CAACC,KAAK,wDAAwDA,KAAK,CAACC,KAAK,CAAG,CACrF,CAAC,CAAC,EAEN,CAAC,mEAEmB,CAClB,IAAI,CAACP,UAAU,CAAG,KAAK,CACvBE,UAAU,CAAC,sBAAsB,CAAC,CACpC,CAAC,uCA4BK,CACJ,MAAOT,qBAACC,gBAAgB,aAAK,IAAI,CAACE,KAAK,EAAI,CAC7C,CAAC,wBAjDqCH,KAAK,CAACe,SAAgB,SAAzCb,UAAW,aAoDhC,GAAIc,kBAAiB,CAAwB,IAAI,CAEjD,QAASP,WAAU,CAACQ,KAAa,EAC/B,GAAID,iBAAiB,CAAE,CACrBA,iBAAiB,CAACE,IAAI,CAACD,KAAK,CAAC,EAEjC,CAEA,MAAM,SAAUE,8BAA6B,GAC3C,GAAI,CAACH,iBAAiB,CAAE,CACtBA,iBAAiB,CAAG,GAAIjB,aAAY,EAAE,EAExC,MAAOiB,kBAAiB,CAC1B","names":["EventEmitter","React","NativeAppLoading","AppLoading","props","onFinish","Error","startAsync","_isMounted","onError","_emitEvent","_startLoadingAppResourcesAsync","catch","console","error","stack","Component","_lifecycleEmitter","event","emit","getAppLoadingLifecycleEmitter"],"sources":["/Users/michaeladmin/Documents/GitHub/vidnation/node_modules/expo/src/launch/AppLoading.tsx"],"sourcesContent":["import { EventEmitter } from 'fbemitter';\nimport React from 'react';\n\nimport NativeAppLoading from './AppLoadingNativeWrapper';\n\ntype Props =\n  | {\n      startAsync?: () => Promise<void>;\n      onError?: (error: Error) => void;\n      onFinish?: () => void;\n      autoHideSplash?: boolean;\n    }\n  | {\n      startAsync: null;\n      onError: null;\n      onFinish: null;\n    };\n\nexport default class AppLoading extends React.Component<Props> {\n  _isMounted: boolean = false;\n\n  componentDidMount() {\n    this._isMounted = true;\n    _emitEvent('componentDidMount');\n\n    // startAsync is optional, you can do this process manually if you prefer (this is mainly for\n    // backwards compatibility and it is not recommended)\n    if (this.props.startAsync) {\n      this._startLoadingAppResourcesAsync().catch(error => {\n        console.error(`AppLoading threw an unexpected error when loading:\\n${error.stack}`);\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n    _emitEvent('componentWillUnmount');\n  }\n\n  _startLoadingAppResourcesAsync = async () => {\n    if (!this.props.onFinish) {\n      throw new Error('AppLoading onFinish prop is required if startAsync is provided');\n    }\n\n    try {\n      await this.props.startAsync!();\n    } catch (e) {\n      if (!this._isMounted) return;\n\n      if (this.props.onError) {\n        this.props.onError(e);\n      } else {\n        throw e;\n      }\n    } finally {\n      if (!this._isMounted) return;\n\n      // If we get to this point then we know that either there was no error, or the error was\n      // handled.\n      if (this.props.onFinish) {\n        this.props.onFinish();\n      }\n    }\n  };\n\n  render() {\n    return <NativeAppLoading {...this.props} />;\n  }\n}\n\nlet _lifecycleEmitter: EventEmitter | null = null;\n\nfunction _emitEvent(event: string): void {\n  if (_lifecycleEmitter) {\n    _lifecycleEmitter.emit(event);\n  }\n}\n\nexport function getAppLoadingLifecycleEmitter(): EventEmitter {\n  if (!_lifecycleEmitter) {\n    _lifecycleEmitter = new EventEmitter();\n  }\n  return _lifecycleEmitter;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}