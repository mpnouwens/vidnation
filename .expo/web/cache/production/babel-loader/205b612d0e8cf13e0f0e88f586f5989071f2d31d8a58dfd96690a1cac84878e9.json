{"ast":null,"code":"import*as React from'react';import NavigationBuilderContext from\"./NavigationBuilderContext\";import useOnPreventRemove,{shouldPreventRemove}from\"./useOnPreventRemove\";export default function useOnAction(_ref){var router=_ref.router,getState=_ref.getState,setState=_ref.setState,key=_ref.key,actionListeners=_ref.actionListeners,beforeRemoveListeners=_ref.beforeRemoveListeners,routerConfigOptions=_ref.routerConfigOptions,emitter=_ref.emitter;var _React$useContext=React.useContext(NavigationBuilderContext),onActionParent=_React$useContext.onAction,onRouteFocusParent=_React$useContext.onRouteFocus,addListenerParent=_React$useContext.addListener,onDispatchAction=_React$useContext.onDispatchAction;var routerConfigOptionsRef=React.useRef(routerConfigOptions);React.useEffect(function(){routerConfigOptionsRef.current=routerConfigOptions;});var onAction=React.useCallback(function(action){var visitedNavigators=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Set();var state=getState();if(visitedNavigators.has(state.key)){return false;}visitedNavigators.add(state.key);if(typeof action.target!=='string'||action.target===state.key){var result=router.getStateForAction(state,action,routerConfigOptionsRef.current);result=result===null&&action.target===state.key?state:result;if(result!==null){onDispatchAction(action,state===result);if(state!==result){var nextRouteKeys=result.routes.map(function(route){return route.key;});var removedRoutes=state.routes.filter(function(route){return!nextRouteKeys.includes(route.key);});var isPrevented=shouldPreventRemove(emitter,beforeRemoveListeners,removedRoutes,action);if(isPrevented){return true;}setState(result);}if(onRouteFocusParent!==undefined){var shouldFocus=router.shouldActionChangeFocus(action);if(shouldFocus&&key!==undefined){onRouteFocusParent(key);}}return true;}}if(onActionParent!==undefined){if(onActionParent(action,visitedNavigators)){return true;}}for(var i=actionListeners.length-1;i>=0;i--){var listener=actionListeners[i];if(listener(action,visitedNavigators)){return true;}}return false;},[actionListeners,beforeRemoveListeners,emitter,getState,key,onActionParent,onDispatchAction,onRouteFocusParent,router,setState]);useOnPreventRemove({getState:getState,emitter:emitter,beforeRemoveListeners:beforeRemoveListeners});React.useEffect(function(){return addListenerParent===null||addListenerParent===void 0?void 0:addListenerParent('action',onAction);},[addListenerParent,onAction]);return onAction;}","map":{"version":3,"mappings":"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","names":["React","NavigationBuilderContext","useOnPreventRemove","shouldPreventRemove","useOnAction","router","getState","setState","key","actionListeners","beforeRemoveListeners","routerConfigOptions","emitter","useContext","onActionParent","onAction","onRouteFocusParent","onRouteFocus","addListenerParent","addListener","onDispatchAction","routerConfigOptionsRef","useRef","useEffect","current","useCallback","action","visitedNavigators","Set","state","has","add","target","result","getStateForAction","nextRouteKeys","routes","map","route","removedRoutes","filter","includes","isPrevented","undefined","shouldFocus","shouldActionChangeFocus","i","length","listener"],"sources":["/Users/michaeladmin/Documents/GitHub/vidnation/node_modules/@react-navigation/core/lib/module/useOnAction.tsx"],"sourcesContent":["import * as React from 'react';\nimport type {\n  NavigationAction,\n  NavigationState,\n  PartialState,\n  Router,\n  RouterConfigOptions,\n} from '@react-navigation/routers';\nimport NavigationBuilderContext, {\n  ChildActionListener,\n  ChildBeforeRemoveListener,\n} from './NavigationBuilderContext';\nimport useOnPreventRemove, { shouldPreventRemove } from './useOnPreventRemove';\nimport type { NavigationEventEmitter } from './useEventEmitter';\nimport type { EventMapCore } from './types';\n\ntype Options = {\n  router: Router<NavigationState, NavigationAction>;\n  key?: string;\n  getState: () => NavigationState;\n  setState: (state: NavigationState | PartialState<NavigationState>) => void;\n  actionListeners: ChildActionListener[];\n  beforeRemoveListeners: Record<string, ChildBeforeRemoveListener | undefined>;\n  routerConfigOptions: RouterConfigOptions;\n  emitter: NavigationEventEmitter<EventMapCore<any>>;\n};\n\n/**\n * Hook to handle actions for a navigator, including state updates and bubbling.\n *\n * Bubbling an action is achieved in 2 ways:\n * 1. To bubble action to parent, we expose the action handler in context and then access the parent context\n * 2. To bubble action to child, child adds event listeners subscribing to actions from parent\n *\n * When the action handler handles as action, it returns `true`, otherwise `false`.\n */\nexport default function useOnAction({\n  router,\n  getState,\n  setState,\n  key,\n  actionListeners,\n  beforeRemoveListeners,\n  routerConfigOptions,\n  emitter,\n}: Options) {\n  const {\n    onAction: onActionParent,\n    onRouteFocus: onRouteFocusParent,\n    addListener: addListenerParent,\n    onDispatchAction,\n  } = React.useContext(NavigationBuilderContext);\n\n  const routerConfigOptionsRef = React.useRef<RouterConfigOptions>(\n    routerConfigOptions\n  );\n\n  React.useEffect(() => {\n    routerConfigOptionsRef.current = routerConfigOptions;\n  });\n\n  const onAction = React.useCallback(\n    (\n      action: NavigationAction,\n      visitedNavigators: Set<string> = new Set<string>()\n    ) => {\n      const state = getState();\n\n      // Since actions can bubble both up and down, they could come to the same navigator again\n      // We keep track of navigators which have already tried to handle the action and return if it's already visited\n      if (visitedNavigators.has(state.key)) {\n        return false;\n      }\n\n      visitedNavigators.add(state.key);\n\n      if (typeof action.target !== 'string' || action.target === state.key) {\n        let result = router.getStateForAction(\n          state,\n          action,\n          routerConfigOptionsRef.current\n        );\n\n        // If a target is specified and set to current navigator, the action shouldn't bubble\n        // So instead of `null`, we use the state object for such cases to signal that action was handled\n        result =\n          result === null && action.target === state.key ? state : result;\n\n        if (result !== null) {\n          onDispatchAction(action, state === result);\n\n          if (state !== result) {\n            const nextRouteKeys = (result.routes as any[]).map(\n              (route: { key?: string }) => route.key\n            );\n\n            const removedRoutes = state.routes.filter(\n              (route) => !nextRouteKeys.includes(route.key)\n            );\n\n            const isPrevented = shouldPreventRemove(\n              emitter,\n              beforeRemoveListeners,\n              removedRoutes,\n              action\n            );\n\n            if (isPrevented) {\n              return true;\n            }\n\n            setState(result);\n          }\n\n          if (onRouteFocusParent !== undefined) {\n            // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree\n            // This means we need to focus all of the parent navigators of this navigator as well\n            const shouldFocus = router.shouldActionChangeFocus(action);\n\n            if (shouldFocus && key !== undefined) {\n              onRouteFocusParent(key);\n            }\n          }\n\n          return true;\n        }\n      }\n\n      if (onActionParent !== undefined) {\n        // Bubble action to the parent if the current navigator didn't handle it\n        if (onActionParent(action, visitedNavigators)) {\n          return true;\n        }\n      }\n\n      // If the action wasn't handled by current navigator or a parent navigator, let children handle it\n      for (let i = actionListeners.length - 1; i >= 0; i--) {\n        const listener = actionListeners[i];\n\n        if (listener(action, visitedNavigators)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    [\n      actionListeners,\n      beforeRemoveListeners,\n      emitter,\n      getState,\n      key,\n      onActionParent,\n      onDispatchAction,\n      onRouteFocusParent,\n      router,\n      setState,\n    ]\n  );\n\n  useOnPreventRemove({\n    getState,\n    emitter,\n    beforeRemoveListeners,\n  });\n\n  React.useEffect(() => addListenerParent?.('action', onAction), [\n    addListenerParent,\n    onAction,\n  ]);\n\n  return onAction;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}